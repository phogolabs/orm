package sql

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/phogolabs/orm/dialect/sql/scan"
)

// PaginateTable paginates a given selector
type PaginateTable struct {
	selector *Selector
	cursor   *Cursor
	err      error
}

// PaginateBy paginates the given selecttor
func (x *Selector) PaginateBy(args ...*Cursor) *PaginateTable {
	if len(args) == 0 {
		args = append(args, &Cursor{})
	}

	paginator := &PaginateTable{
		selector: x.Clone(),
		cursor:   args[0],
	}

	return paginator.seek()
}

// Cursor returns the underlying cursor
func (pg *PaginateTable) Cursor() *Cursor {
	if pg.cursor.valid() {
		return pg.cursor
	}

	return nil
}

// Err returns the underlying error
func (pg *PaginateTable) Err() error {
	err := pg.selector.Err()
	// check the paginator error
	if err == nil {
		err = pg.err
	}

	return err
}

// Dialect returns the dialect
func (pg *PaginateTable) Dialect() string {
	return pg.selector.dialect
}

// SetDialect sets the dialect
func (pg *PaginateTable) SetDialect(dialect string) {
	pg.selector.SetDialect(dialect)
}

// Query returns the query
func (pg *PaginateTable) Query() (string, []interface{}) {
	return pg.selector.Query()
}

// Scan scans the target
func (pg *PaginateTable) Scan(target interface{}) error {
	value := reflect.Indirect(reflect.ValueOf(target))

	if value.Kind() != reflect.Slice {
		return fmt.Errorf("sql: invalid type %T. expect []interface{}", target)
	}

	count := value.Len()
	// if we do not have any items we should not proceed
	if count == 0 {
		// reset the token
		pg.cursor = &Cursor{}
		return nil
	}

	if limit := pg.selector.limit; limit != nil {
		if int(count) < *limit {
			// reset the token
			pg.cursor = &Cursor{}
			return nil
		}
	}

	// get the last item
	item := value.Index(count - 1)
	// remove the last item
	value.Set(value.Slice(0, count-1))
	// selector order
	orderBy := pg.selector.Order()

	columns := orderBy.Columns()
	// extract the column values
	whereAt, err := scan.Values(item.Interface(), columns...)
	if err != nil {
		return err
	}

	if len(columns) != len(whereAt) {
		return fmt.Errorf("sql: the order clause should have valid cursor vector")
	}

	pg.cursor = &Cursor{
		OrderBy: orderBy,
		WhereAt: whereAt,
	}

	return nil
}

func (pg *PaginateTable) seek() *PaginateTable {
	if limit := pg.selector.limit; limit != nil {
		next := *limit + 1
		pg.selector.limit = &next
	}

	if err := pg.cursor.where(pg.selector); err != nil {
		pg.err = err
		return pg
	}

	if err := pg.cursor.order(pg.selector); err != nil {
		pg.err = err
		return pg
	}

	if len(pg.selector.order) == 0 {
		pg.err = fmt.Errorf("sql: query should have at least one order by clause")
	}

	return pg
}

// Cursor represents the pagination position
type Cursor struct {
	OrderBy *Order        `json:"order_by"`
	WhereAt []interface{} `json:"where_at"`
}

// MarshalBinary encodes the receiver into a binary form and returns the result.
func (c *Cursor) MarshalBinary() ([]byte, error) {
	var (
		err  error
		data []byte
	)

	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("%v", r)
		}
	}()

	if c.valid() {
		source, err := json.Marshal(c)
		if err != nil {
			return nil, err
		}

		var target []byte
		// encode
		base64.URLEncoding.Encode(target, source)
		// prepare the target
		data = bytes.Trim(target, "=")
	}

	// done!
	return data, err
}

// UnmarshalBinary must be able to decode the form generated by MarshalBinary.
// UnmarshalBinary must copy the data if it wishes to retain the data after
// returning.
func (c *Cursor) UnmarshalBinary(source []byte) error {
	var err error

	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("%v", r)
		}
	}()

	if len(source) > 0 {
		if n := len(source) % 4; n != 0 {
			suffix := []byte("=")
			suffix = bytes.Repeat(suffix, 4-n)
			// prepare the data
			source = append(source, suffix...)
		}

		var target []byte
		// decode
		if _, err = base64.URLEncoding.Decode(target, source); err != nil {
			return err
		}

		if err = json.Unmarshal(target, c); err != nil {
			return err
		}
	}

	// done!
	return err
}

func (c *Cursor) valid() bool {
	return c != nil && c.OrderBy != nil && c.WhereAt != nil
}

func (c *Cursor) where(selector *Selector) error {
	if c.OrderBy == nil {
		return nil
	}

	if predicate := c.predicate(0); predicate != nil {
		selector.Where(predicate)
	}

	return nil
}

func (c *Cursor) order(selector *Selector) error {
	if c.OrderBy == nil {
		return nil
	}

	var (
		ccount = len(c.OrderBy.columns)
		porder = selector.Order()
		pcount = len(porder.columns)
		pindex = 0
	)

	for cindex, vector := range c.OrderBy.columns {
		source := &OrderColumn{
			column: vector.column,
			order:  vector.order,
		}

		switch {
		case pcount == 0, cindex > pindex:
			selector.order = append(selector.order, source)
		default:
			if target := porder.columns[pindex]; !source.Equal(target) {
				return fmt.Errorf("sql: pagination cursor order by mismatch")
			}
		}

		if pindex+1 < pcount {
			pindex++
		}

		if cindex != ccount-1 {
			continue
		}
	}

	return nil
}

func (c *Cursor) predicate(index int) *Predicate {
	if index >= len(c.OrderBy.columns) {
		return nil
	}

	var (
		order = c.OrderBy.columns[index]
		value = c.WhereAt[index]
	)

	var (
		predicateCmp *Predicate
		predicateEQ  = EQ(order.column, value)
	)

	switch order.order {
	case "asc":
		predicateCmp = GT(order.column, value)
	case "desc":
		predicateCmp = LT(order.column, value)
	}

	predicate := c.predicate(index + 1)

	switch {
	case predicate != nil:
		predicate = Or(predicateCmp, And(predicateEQ, predicate))
	case predicate == nil:
		predicate = Or(predicateCmp, predicateEQ)
	}

	return predicate
}
